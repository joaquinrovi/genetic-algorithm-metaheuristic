import pandas as pd
import numpy as np
import random as rd

def append_column_solution(
        df_optional,
        df_mandatory,
        df_zeros,
        df_semi_mandatory,
        portfolios,
        portfolios_semi_mandatory
):
    """
    Function that joins the portfolios of the optional projects and appends the mandatory and
    vpn zero projects, while adding some columns that improve the understanding of the results DataFrame.
    The returned df of this function is later stored as a table

    :param df_optional: DataFrame with the optional projects evaluated by the model
    :type df_optional: DataFrame
    :param df_mandatory: DataFrame with the mandatory projects
    :type df_mandatory: DataFrame
    :param df_zeros: DataFrame with the vpn zero projects
    :type df_zeros: DataFrame
    :param df_semi_mandatory: DataFrame with the df_semi_mandatory projects
    :type df_semi_mandatory: DataFrame
    :param portfolios: list with the different portfolios generated by the model
    :type config: list
    :param portfolios_semi_mandatory: list with the different portfolios generated by the model for semi_mandatory
    projects
    :type config: list

    Return: DataFrame with all the projects and portfolios generated by the model
    :rtype DataFrame
    """

    columns = [
        "MATRICULA_DIGITAL",
        "NOMBRE_PROYECTO",
        "ACTIVO",
        "EMPRESA",
        "TIPO_DE_INVERSION",
        "FASE_EN_CURSO",
        "SEGMENTO"
    ]

    df1 = (
        df_optional[columns]
        .groupby(["MATRICULA_DIGITAL", "NOMBRE_PROYECTO"], sort=False, as_index=False)
        .min()
    )
    df2 = (
        df_mandatory[columns]
        .groupby(["MATRICULA_DIGITAL", "NOMBRE_PROYECTO"], sort=False, as_index=False)
        .min()
    )
    df3 = (
        df_zeros[columns]
        .groupby(["MATRICULA_DIGITAL", "NOMBRE_PROYECTO"], sort=False, as_index=False)
        .min()
    )
    df4 = (
        df_semi_mandatory[columns]
        .groupby(["MATRICULA_DIGITAL", "NOMBRE_PROYECTO"], sort=False, as_index=False)
        .min()
    )
    # df5 = pd.DataFrame({"MATRICULA_DIGITAL": ["FITNESS"]})
    df5 = pd.DataFrame(
        {
            "MATRICULA_DIGITAL": [
                "grb-portafolio_1",
                "grc-portafolio_1",
                "grb-portafolio_2",
                "grc-portafolio_2",
                "grb-portafolio_3",
                "grc-portafolio_3",
                "grb-portafolio_4",
                "grc-portafolio_4",
                "grb-portafolio_5",
                "grc-portafolio_5",
                "grb-portafolio_6",
                "grc-portafolio_6",
            ],
            "PORTAFOLIO_1": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            "PORTAFOLIO_2": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
            "PORTAFOLIO_3": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
            "PORTAFOLIO_4": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
            "PORTAFOLIO_5": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
            "PORTAFOLIO_6": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]
        }
    )
    mid_portfolios = [1 for i in range(14)]
    df6 = pd.DataFrame({
        "MATRICULA_DIGITAL": [
            f"MID{i + 1}" for i in range(14)
        ],
        "PORTAFOLIO_1": mid_portfolios,
        "PORTAFOLIO_2": mid_portfolios,
        "PORTAFOLIO_3": mid_portfolios,
        "PORTAFOLIO_4": mid_portfolios,
        "PORTAFOLIO_5": mid_portfolios,
        "PORTAFOLIO_6": mid_portfolios
    }
    )

    df_con = pd.concat([df1, df2, df3, df4], ignore_index=True)

    zeros = np.zeros((portfolios.shape[0], df3.shape[0]))
    ones = np.ones((portfolios.shape[0], df2.shape[0]))
    portfolios_con = np.concatenate(
        (portfolios, ones, zeros, portfolios_semi_mandatory), axis=1
    ).transpose()
    df_portfolios = pd.DataFrame(
        portfolios_con,
        columns=[f"PORTAFOLIO_{i + 1}" for i in range(portfolios_con.shape[1])],
    )

    df_con = pd.concat([df_con, df_portfolios], axis=1)
    df_con["PORTAFOLIO_6"] = 1
    df_con = pd.concat([df_con, df5, df6], axis=0)

    return df_con


def get_down_projects_params(df_down, initial, config):
    """
    Function that gets downstream refineries attributes
    :param df_down: df containing info about refineries
    :type df_down: DataFrame
    :param initial: Tells if this is an initial run where down and mid are not considered or if it is a normal execution
    :type initial: bool
    :param config: Dictionary containing config of model
    :type config: Dictionary

    :return: attributes of the refineries by year
    :rtype tuple(np.array, np.array, np.array, np.array, np.array)
    """
    if initial:
        return (np.zeros(config["records_per_project"]),
                np.zeros(config["records_per_project"]),
                np.zeros(config["records_per_project"]),
                np.zeros(config["records_per_project"]),
                np.zeros(config["records_per_project"]),
                )

    columns = [
        "MATRICULA_DIGITAL",
        "EBITDA",
        "CAPEX",
        "EMISIONES_NETAS_CO2_ALCANCE_1_Y_2",
        "FLUJO_CAJA",
        "DIVIDENDO",
        "IMPUESTOS",
        "LINEA_DE_NEGOCIO",
        "ACTIVO",
        "EMPRESA",
        "RANGO_ANIO",
        "ANIO_INICIAL",
        "ANIO_FINAL",
        "DEPENDENCIAS", # Datos de dependencias
        "EXCLUYENTES", # Datos de excluyentes
    ]

    df = df_down[columns]

    df_year = df.groupby("RANGO_ANIO")
    emissions = df_year["EMISIONES_NETAS_CO2_ALCANCE_1_Y_2"].sum().to_numpy()
    ebitda = df_year["EBITDA"].sum().to_numpy()
    global_nation = (df_year["DIVIDENDO"].sum() + df_year["IMPUESTOS"].sum()).to_numpy()
    capex = df_year["CAPEX"].sum().to_numpy()
    flow = df_year["FLUJO_CAJA"].sum().to_numpy()
    dependientes = df_year["DEPENDENCIAS"] # Posible manera de llamar la columna de dependencias
    excluyentes = df_year['EXCLUYENTES'] # Posible manera de llamar la columna de dependencias

    return capex, ebitda, emissions, global_nation, flow


def get_mid_projects_params(df_mid, initial, config):
    """
    Function that gets midstream attributes

    :param df_mid: df containing info about mid
    :type df_mid: DataFrame
    :param initial: Tells if this is an initial run where down and mid are not considered or if it is a normal execution
    :type initial: bool
    :param config: Dictionary containing config of model
    :type config: Dictionary

    :return: attributes of the mid by year
    :rtype tuple(np.array, np.array, np.array, np.array, np.array)
    """
    if initial:
        return (np.zeros(config["records_per_project"]),
                np.zeros(config["records_per_project"]),
                np.zeros(config["records_per_project"]),
                np.zeros(config["records_per_project"]),
                np.zeros(config["records_per_project"]),
                )
    columns = [
        "MATRICULA_DIGITAL",
        "EBITDA",
        "CAPEX",
        "EMISIONES_NETAS_CO2_ALCANCE_1_Y_2",
        "FLUJO_CAJA",
        "DIVIDENDO",
        "IMPUESTOS",
        "LINEA_DE_NEGOCIO",
        "ACTIVO",
        "EMPRESA",
        "RANGO_ANIO",
    ]
    df = df_mid[columns]
    df_year = df.groupby("RANGO_ANIO")
    emissions = df_year["EMISIONES_NETAS_CO2_ALCANCE_1_Y_2"].sum().to_numpy()
    ebitda = df_year["EBITDA"].sum().to_numpy()
    capex = df_year["CAPEX"].sum().to_numpy()
    flujo = df_year["FLUJO_CAJA"].sum().to_numpy()
    global_nation = (df_year["DIVIDENDO"].sum() + df_year["IMPUESTOS"].sum()).to_numpy()
    return capex, ebitda, emissions, flujo, global_nation


def filter_projects(df, zero_restriction, phase_restriction, be_restriction, config, params):
    """
    Function to get different dataframes from the input data

    :param df: DataFrame with the input data
    :type df: Dictionary
    :param zero_restriction: bool that indicates if zero restriction is on or off
    :type zero_restriction: bool
    :param phase_restriction: bool that indicates if phase restriction is on or off
    :type phase_restriction: bool
    :param config: Dictionary containing configs from excel and json
    :type config: Dictionary
    :param params: Dictionary containing configs from BI
    :type params: Dictionary

    :return
    DataFrame: DataFrame with the projects to be evaluated
    DataFrame: DataFrame with the projects with vpn negative or zero
    DataFrame: DataFrame with the mandatory projects for every portfolio
    DataFrame: DataFrame with the semi mandatory projects for every portfolio

    :rtype tuple(DataFrame, DataFrame, DataFrame, DataFrame)
    """

    columns = [
        "ID_PROYECTO",
        "MATRICULA_DIGITAL",
        "FASE_EN_CURSO",
        "MW_INCORPORADOS",
        "RANGO_ANIO",
        "DURACION",
        "EBITDA",
        "EMISIONES_NETAS_CO2_ALCANCE_1_Y_2",
        "AGUA_NEUTRALIDAD",
        "CAPEX",
        "TOTAL_R_NACION",
        "DIVIDENDO",
        "IMPUESTOS",
        "ANIO_INICIAL",
        "ANIO_FINAL",
        "VPN_PLP_CALCULADO",
        "NOMBRE_PROYECTO",
        "LINEA_DE_NEGOCIO",
        "EBIT",
        "CAPITAL_EMPLEADO",
        "TIPO_DE_INVERSION",
        "OPCION_ESTRATEGICA",
        "FLUJO_CAJA",
        "ACTIVO",
        "EMPRESA",
        "SEGMENTO",
        "EMPLEOS_NP",
        "ESTUDIANTES",
        "ACCESO_AGUA_POTABLE",
        "ACCESO_GAS",
        "KM",
        "APORTE_EBITDA_ACUM_2040_PROYECTOS_ASOCIADOS_A_CTI",
        "B_E_CRUDO"
    ]
    val_curva_crudo = str(params['val_curva_crudo'])
    val_curva_crudo = val_curva_crudo[0]
    precio_crudo = [i * params["val_sensi_precio_crudo"] for i in config[f"precio_crudo_{val_curva_crudo}"]]
    avg_precio_crudo = np.average(precio_crudo)
    df = df[columns]
    df_no_duration = df[df["DURACION"].isnull()]
    df2 = df.dropna(subset=["DURACION"]).copy()
    df2.fillna(0, inplace=True)
    # df2["APORTE_EBITDA_ACUM_2040_PROYECTOS_ASOCIADOS_A_CTI"] = 40 / df2.shape[0]
    # df2["EMPLEOS_NP"] = 460 / df2.shape[0]
    # df2["ESTUDIANTES"] = 4 / df2.shape[0]
    # df2["ACCESO_AGUA_POTABLE"] = 40 / df2.shape[0]
    # df2["ACCESO_GAS"] = 460 / df2.shape[0]
    # df2["KM"] = 4 / df2.shape[0]

    df_optional = df2.loc[
        (((df2["VPN_PLP_CALCULADO"] >= 0)
          & (df2["B_E_CRUDO"] <= avg_precio_crudo))
         & (~df2["TIPO_DE_INVERSION"].isin(["ICO - Mto Mayor", "ICO - Normativo"]))
         & (~df2["FASE_EN_CURSO"].isin(["Fase 4", "Fase 5"])))
    ].copy()

    df_zeros = df2.loc[
        ((df2["VPN_PLP_CALCULADO"] < 0)
         & (~df2["TIPO_DE_INVERSION"].isin(["ICO - Mto Mayor", "ICO - Normativo"]))
         & (~df2["FASE_EN_CURSO"].isin(["Fase 4", "Fase 5"])))
    ]

    df_be = df2.loc[
        ((df2["B_E_CRUDO"] > avg_precio_crudo)
         & (~df2["TIPO_DE_INVERSION"].isin(["ICO - Mto Mayor", "ICO - Normativo"]))
         & (~df2["FASE_EN_CURSO"].isin(["Fase 4", "Fase 5"])))
    ]

    df_temp = df2.loc[
        (df2["TIPO_DE_INVERSION"].isin(["ICO - Mto Mayor", "ICO - Normativo"]))
        | (df2["FASE_EN_CURSO"].isin(["Fase 4", "Fase 5"]))
        ]

    df_mandatory = df_temp.loc[(df2["TIPO_DE_INVERSION"].isin(["Básica"]))]

    df_semi_mandatory = df_temp.loc[(~df2["TIPO_DE_INVERSION"].isin(["Básica"]))]

    if not zero_restriction:
        df_optional = pd.concat([df_optional, df_zeros])
        df_zeros = pd.DataFrame({}, columns=columns)
    if not be_restriction:
        df_optional = pd.concat([df_optional, df_be])
        df_be = pd.DataFrame({}, columns=columns)

    if not phase_restriction:
        df_temp_2 = df_semi_mandatory.loc[
            df_semi_mandatory["FASE_EN_CURSO"].isin(["Fase 4", "Fase 5"])
            & (
                ~df_semi_mandatory["TIPO_DE_INVERSION"].isin(
                    ["ICO - Mto Mayor", "ICO - Normativo"]
                )
            )
            ]
        df_optional = pd.concat([df_optional, df_temp_2])
        df_semi_mandatory = df_semi_mandatory.loc[
            (
                df_semi_mandatory["TIPO_DE_INVERSION"].isin(
                    ["ICO - Mto Mayor", "ICO - Normativo"]
                )
            )
        ]

    index = -1
    df_optional.loc[:, "INDEX"] = [
        index := index + 1 if i % config["records_per_project"] == 0 else index
        for i in range(df_optional.shape[0])
    ]
    df_zeros_2 = pd.concat([df_zeros, df_no_duration, df_be])
    return df_optional, df_zeros_2, df_mandatory, df_semi_mandatory


def get_project_params(df, config):
    """
    Function to get the params per year of a portfolio

    :param df: Pandas.DataFrame with the projects to extract the param values
    :type df: DataFrame
    :param config: Dictionary containing different configs
    :type config: Dictionary

    :usage:

    get_project_params(df,18)

    :return:
    numpy.array: array of vpn value for each year
    numpy.array: array of water value for each year
    numpy.array: array of co2 value for each year
    numpy.array: array of energy value for each year
    numpy.array: array of ebidta value for each year
    numpy.array: array of ebidta value for low emission projects for each year
    numpy.array: array of global nation for each year

    :rtype tuple(np.array, np.array, np.array, np.array, np.array, np.array, np.array)
    """
    if df.shape[0] == 0:
        return (
            np.zeros(config["records_per_project"]),
            np.zeros(config["records_per_project"]),
            np.zeros(config["records_per_project"]),
            np.zeros(config["records_per_project"]),
            np.zeros(config["records_per_project"]),
            np.zeros(config["records_per_project"]),
            np.zeros(config["records_per_project"]),
            np.zeros(config["records_per_project"]),
            np.zeros(config["records_per_project"]),
            np.zeros(config["records_per_project"]),
            np.zeros(config["records_per_project"]),
            np.zeros(config["records_per_project"]),
            np.zeros(config["records_per_project"]),
        )
    df_range = df.loc[
        (df["RANGO_ANIO"] >= df["ANIO_INICIAL"])
        & (df["RANGO_ANIO"] <= df["ANIO_FINAL"])
        ]

    anios = df_range['RANGO_ANIO'].unique()

    if len(anios) < config["records_per_project"]:
        df_range = check_length(df_range, config)

    df_range = df_range.groupby("RANGO_ANIO")

    water = df_range["AGUA_NEUTRALIDAD"].sum()
    co2 = df_range["EMISIONES_NETAS_CO2_ALCANCE_1_Y_2"].sum()
    energy = df_range["MW_INCORPORADOS"].sum()
    ebidta = df_range["EBITDA"].sum()
    ebidta_low_emission = df_range.apply(
        lambda x: x.loc[
            (x.loc[:, "LINEA_DE_NEGOCIO"] == "Bajas Emisiones") |
            (x.loc[:, "LINEA_DE_NEGOCIO"] == "Transmisión y Vías"), "EBITDA"
        ].sum()
    )
    employee_cap = df_range["CAPITAL_EMPLEADO"].sum()
    global_nation = (
            df_range["DIVIDENDO"].sum()
            + df_range["IMPUESTOS"].sum()
            + df_range["TOTAL_R_NACION"].sum()
    )
    # cti = df_range["APORTE_EBITDA_ACUM_2040_PROYECTOS_ASOCIADOS_A_CTI"].sum()
    try:
        cti = df_range.apply(
            lambda x: x.loc[
                (x.loc[:, "SEGMENTO"] == "Corporativo"), "EBITDA"
            ].sum()
        )
    except:
        cti = np.zeros(config["records_per_project"])
    not_oil_jobs = df_range["EMPLEOS_NP"].sum()
    students = df_range["ESTUDIANTES"].sum()
    access_water = df_range["ACCESO_AGUA_POTABLE"].sum()
    access_gas = df_range["ACCESO_GAS"].sum()
    km = df_range["KM"].sum()
    vpn = df_range["VPN_PLP_CALCULADO"].sum()

    return (
        water,
        co2,
        energy,
        ebidta,
        ebidta_low_emission,
        global_nation,
        cti,
        not_oil_jobs,
        students,
        access_water,
        access_gas,
        km,
        vpn
    )


def get_capex_portfolio(df, config):
    """
    Function to get the params per year of a portfolio

    :param df: Pandas.DataFrame with the projects to extract the param values
    :type df: DataFrame
    :param config: Dictionary containing different configs
    :type config: Dictionary

    :usage:

    get_capex_portfolio(df,config)

    :return:
    numpy.array: array of capex value for each year
    :rtype np.array
    """
    if df.shape[0] == 0:
        return np.zeros(config["records_per_project"])
    df_range = df.loc[
        (df["RANGO_ANIO"] >= df["ANIO_INICIAL"])
        & (df["RANGO_ANIO"] <= (df["ANIO_FINAL"]))
        ]

    anios = df_range['RANGO_ANIO'].unique()

    if len(anios) < config["records_per_project"]:
        df_range = check_length(df_range, config)

    df_year = df_range.groupby("RANGO_ANIO")
    capex = df_year["CAPEX"].sum().to_numpy()

    return capex


def check_length(df, config):
    df_copy = df.copy()
    start_year = config["start_year"]
    cur_year = config["start_year"]

    while cur_year < start_year + config["records_per_project"]:
        new_row = pd.DataFrame(0, index=[0], columns=df_copy.columns)
        new_row.update(pd.DataFrame({"RANGO_ANIO": cur_year}, index=[0]))
        df_copy = df_copy.append(new_row, ignore_index= True)
        cur_year += 1
    return df_copy

def get_flujo_portfolio(df, config):
    """
    Function to get the flow per year of a portfolio

    :param df: Pandas.DataFrame with the projects to extract the param values
    :type df: DataFrame
    :param config: Dictionary containing different configs
    :type config: Dictionary

    :usage:

    get_flujo_portfolio(df,config)

    :return:
    numpy.array: array of flow value for each year
    :rtype np.array
    """
    if df.shape[0] == 0:
        return np.zeros(config["records_per_project"])
    df_range = df.loc[
        (df.loc[:, "RANGO_ANIO"] >= df.loc[:, "ANIO_INICIAL"])
        & (df.loc[:, "RANGO_ANIO"] <= (df.loc[:, "ANIO_FINAL"]))
        ]
    anios = df_range['RANGO_ANIO'].unique()

    if len(anios) < config["records_per_project"]:
        df_range = check_length(df_range, config)

    df_range = df_range.groupby("RANGO_ANIO", as_index=False)[["FLUJO_CAJA"]].sum()

    return df_range.loc[:, "FLUJO_CAJA"].to_numpy()


def get_projects(df, portfolio):
    """
    Function to get a dataframe with the projects to leave on

    :param df: Pandas.DataFrame with the projects considered
    :type df: DataFrame
    :param portfolio: list of projects on or off
    :type portfolio: list

    :usage:
    get_projects(df,[0,1])

    :return:
    Pandas.DataFrame: Dataframe with the data of the projects selected in the portfolio
    :rtype Dataframe
    """

    projects = df["MATRICULA_DIGITAL"].unique()
    projects_on = projects[np.array(portfolio, dtype="bool")]
    return df.loc[df["MATRICULA_DIGITAL"].isin(projects_on)]


def get_off_actives(df, portfolio):
    """
    Function to get the actives with basic off

    :param df: DataFrame with the projects to extract the off projects
    :type df: DataFrame
    :param portfolio: list with 1 and 0 that represent projects on or off
    :type portfolio: list

    :usage:
        get_off_actives(df, portfolio)
    :return: array with actives which basic are off in the portfolio
    :rtype np.array
    """

    df_off_projects = get_projects(df, (1 - portfolio))
    df_off_basic = df_off_projects.loc[
        df_off_projects["TIPO_DE_INVERSION"] == "Básica"
        ]
    return df_off_basic["ACTIVO"].unique()
    

def get_indexes_turn_off(df, actives):
    """
    Function to return the index of the projects which basics are off

    :param df: df containing the projects
    :type df: DataFrame
    :param actives: array with the actives off
    :type actives: np.array

    :usage:
    indexes_turn_off(df, actives)

    :return: Index of the projects
    :rtype np.array
    """

    return df.loc[df["ACTIVO"].isin(actives), "INDEX"].unique()


def get_semi_mandatory_on(df, actives):
    """
    Function to get the projects on phase 4 that are on in the portfolio

    :param df: df containing the projects of phase 4
    :type df: DataFrame
    :param actives: array with the actives off
    :type actives: np.array

    :usage:
    get_semi_mandatory_on(df, actives)

    :return: DataFrame of projects on
    :rtype DataFrame
    """

    return df.loc[~df["ACTIVO"].isin(actives)]


def get_indexes_isa(df):
    """
    Function to return the index of the projects in which the column EMPRESA equals ISA

    :param df: df containing the projects
    :type df: DataFrame

    :usage:
    indexes_isa(df)

    :return: Index of the projects
    :rtype np.array
    """

    return df.loc[df["EMPRESA"] == "ISA", "INDEX"].unique()


def get_basic_index(df):
    """
    Function to return the index of the projects in which the column EMPRESA equals ISA
    :param df: df containing the projects
    :type df: DataFrame

    :usage:
    indexes_isa(df)

    :return: Index of the projects
    :rtype np.array
    """

    return df.loc[df["TIPO_DE_INVERSION"] == "Básica", "INDEX"].unique()


def check_isa(mutant, indexes_isa):
    """
    Function to check ISA restriction, in this function the array is passed by reference bacause of this
    it is modified here without the need of returning it

    :param mutant: np.array containing the portafolio to be checked
    :type mutant: np.array
    :param indexes_isa: np.array containing index location of ISA projects
    :type indexes_isa: np.array

    :return: None

    """

    while mutant[indexes_isa].sum() > 1:
        ran = rd.randrange(0, len(indexes_isa))
        mutant[indexes_isa[ran]] = 0

    if mutant[indexes_isa].sum() == 0:
        ran = rd.randrange(0, len(indexes_isa))
        mutant[indexes_isa[ran]] = 1

def check_capex(mutant, df_projects, df_semi_mandatory, mandatory_capex, actives_off, config):
    """
    Function to check capex restriction, in this function the array is passed by reference because of this
    it is modified here without the need of returning it

    Args:
        mutant:
        df_projects:
        df_semi_mandatory:
        mandatory_capex:
        actives_off:
        config:

    Returns:

    :param mutant: np.array containing the portafolio to be checked
    :type mutant: np.array
    :param df_projects: df containing projects
    :type df_projects: DataFrame
    :param df_semi_mandatory: df containing semi mandatory projects
    :type df_semi_mandatory: DataFrame
    :param mandatory_capex: np.array containing the mandatory capex for each year
    :type mandatory_capex: np.array
    :param actives_off: np.array actives with basic off
    :type actives_off: np.array
    :param config: dictionary containing configs
    :type config: dictionary

    :return: None

    """
    capex_semi_mandatory = get_capex_portfolio(
        get_semi_mandatory_on(df_semi_mandatory, actives_off),
        config
    )
    # check capex is in budget
    df_projects_on = get_projects(df_projects, mutant)
    capex = get_capex_portfolio(df_projects_on, config)
    overbudget_years = np.where(
        (capex + mandatory_capex + capex_semi_mandatory)
        > config["capex_yearly_budget"]
    )[0]

    while len(overbudget_years) > 0:
        durations = (
                df_projects_on["ANIO_INICIAL"]
                - config["start_year"]
                + df_projects_on["DURACION"]
        )
        for j, year in enumerate(overbudget_years):
            df_year = df_projects_on[durations > year]
            project = df_year.iloc[rd.randrange(0, df_year.shape[0])]
            # ensure not to turn off basic or ISA project
            while (
                    project.loc["TIPO_DE_INVERSION"] == "Básica"
                    or project.loc["EMPRESA"] == "ISA"
            ):
                project = df_year.iloc[rd.randrange(0, df_year.shape[0])]
            project_index = project.loc["INDEX"]
            mutant[project_index] = 0

        df_projects_on = get_projects(df_projects, mutant)
        capex = get_capex_portfolio(df_projects_on, config)
        actives_off = get_off_actives(df_projects, mutant)

        capex_semi_mandatory = get_capex_portfolio(
            get_semi_mandatory_on(df_semi_mandatory, actives_off),
            config
        )
        overbudget_years = np.where(
            (capex + mandatory_capex + capex_semi_mandatory)
            > config["capex_yearly_budget"]
        )[0]
    # end loop mutants


def check_selected_projects(df_dependencies):
    """
    Selects projects based on their dependencies and exclusions.

    This function takes a DataFrame containing project information as input and selects projects that can be executed considering their dependencies and exclusions.
    
    :param df: DataFrame containing project information including 'NOMBRE_PROYECTO' (Project), 'DEPENDENCIAS' (Dependencies), and 'EXCLUYENTES' (Exclusions).
    :type df: pandas.DataFrame

    :return: List of projects that are available for selection based on their dependencies and exclusions.
    :rtype: list
    """
    available_projects = []
    selected_projects = set()
    exclusive_projects = set()
    for index, row in df_dependencies.iterrows():
        project = row['NOMBRE_PROYECTO']
        dependencies = row['DEPENDENCIAS']
        exclusions = row['EXCLUYENTES']
        if dependencies == '' and not any(dep in exclusive_projects for dep in [project]):
            available_projects.append(project)
        else:
            dependencies = [dep.strip() for dep in dependencies.split(',')]
            if all(dep in selected_projects for dep in dependencies) and not any(dep in exclusive_projects for dep in [project]):
                available_projects.append(project)
        selected_projects.add(project)
        exclusions = [ex.strip() for ex in exclusions.split(',')]
        exclusive_projects.update(exclusions)
    return available_projects

def generate_initial_population(
        sol_per_pop,
        num_genes,
        df,
        df_semi_mandatory,
        isa_index,
        mandatory_capex,
        config
):
    """
    Funcion that creates an initial population given the solutions per population, number of genes
    and the data. All the basic projects will be set to one, and the capex restriction is met from the start
    :param sol_per_pop: solutions per population
    :type df: int
    :param num_genes: number of genes
    :type df: int
    :param df: data containing projects
    :type df: DataFrame
    :param df_semi_mandatory: data containing semi_mandatory projects
    :type df_semi_mandatory: DataFrame
    :param isa_index: array containing index of ISA projects
    :type isa_index: np.array
    :param mandatory_capex: array containing mandatory capex
    :type mandatory_capex: np.array
    :param config: Dictionary containing configurations
    :type config: Dictionary

    :return: np array containing the population
    :rtype np.array
    """
    values = [0, 1]
    initial_population = np.random.choice(values, size=(sol_per_pop, num_genes))
    basic_index = get_basic_index(df)
    for i in basic_index:
        initial_population[:, i] = 1

    for portfolio in initial_population:
        # turn off projects with basic off
        actives_off = get_off_actives(df, portfolio)
        indexes_turn_off = get_indexes_turn_off(df, actives_off)
        portfolio[indexes_turn_off] = 0

        # check ISA
        check_isa(portfolio, isa_index)

        check_capex(portfolio, df, df_semi_mandatory, mandatory_capex, actives_off, config)

    return initial_population


def calc_fitness_water(water: np.array, actual, coefficient: float):
    """
    Method to calculate the fitness of water used in a solution

    :Usage:

    self.penalize_water(water, 0.25)

    :param water: array with the quantity of water for all years
    :type water: np.array
    :param actual: Actual value present in the model config
    :type actual: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float
    :return:
        np.array: fitness of water for each year
    :rtype np.array
    """

    return -(water / actual) * coefficient


def calc_fitness_co2(co2: np.array, actual, coefficient: float):
    """
    Method calculate the fitness of co2 used in a solution

    :Usage:

    self.penalize_co2(co2, 0.25)

    :param co2: array with the quantity of co2 for all years
    :type co2: np.array
    :param actual: Actual value present in the model config
    :type actual: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float
    :return:
        np.array: fitness of co2 for each year
    :rtype np.array
    """

    return -(co2 / actual) * coefficient


def calc_fitness_energy(energy: np.array, goal, coefficient: float):
    """
    Method to calculate the fitness energy used in a solution

    :Usage:

    self.penalize_energy(energy, 0.25)

    :param energy: array with the quantity of energy for all years
    :type energy: np.array
    :param goal: Goal value present in the model config
    :type goal: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float
    :return:
        np.array: fitness energy
    :rtype np.array
    """

    return (energy / goal) * coefficient


def calc_fitness_gross(total_ebitda: np.array, deuda, ratio, coefficient: float, per_project=False, max_fit=False):
    """
    Method to calculate the fitness of the gross for a solution

    :Usage:

    self.penalize_gross(ebidta, 0.25)

    :param total_ebitda: array with the total ebitda for all years
    :type total_ebitda: np.array
    :param deuda: array with the deuda restriction
    :type deuda: np.array
    :param ratio: ratio present in the config
    :type ratio: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float
    :return:
        np.array: fitness of gross
    :rtype np.array
    """
    if isinstance(total_ebitda, np.float64):
        debt_ratio = np.average(deuda) / total_ebitda

    else:
        debt_ratio = np.divide(
            deuda,
            total_ebitda,
            out=np.zeros_like(total_ebitda),
            where=total_ebitda != 0,
        )
    ratio = np.divide(
        ratio,
        debt_ratio,
        out=np.zeros_like(debt_ratio),
        where=debt_ratio != 0,
    )
    return ratio * coefficient


def calc_fitness_ebitda(total_ebitda: np.array, minimum, coefficient: float):
    """
    Method to calculate the fitness of ebitda for a solution

    :Usage:

    self.penalize_ebitda(ebitda, 0.25)

    :param total_ebitda: array with the total ebitda for all years
    :type total_ebitda: np.array
    :param minimum: minimum value present in the model config
    :type minimum: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float
    :return:
        np.array: fitness of ebitda
    :rtype np.array
    """

    return (total_ebitda / minimum) * coefficient


def calc_fitness_low_emissions(
        total_ebitda: np.array,
        total_low_ebitda: np.array,
        minimum,
        coefficient: float,
        goal=False
):
    """
    Method  to calculate the fitness of low emissions used in a solution

    :param total_low_ebitda: array with the total sum of low emissions projects for all years
    :type total_low_ebitda: np.array
    :param total_ebitda: array with the total sum of all projects ebitda for all years
    :type total_ebitda: np.array
    :param minimum: minimum value present in the model config
    :type minimum: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float
    :param goal: Parameter that tells if we just want the goal or if we want the fitness
    :type goal: bool

    :Usage:

    self.penalize_low_emissions(ebidta, low_emission_ebidta, 0.25)

    :return:
        np.array: fitness low emission
    :rtype np.array
    """

    def check(values):
        if values > 2.5:
            return 1
        elif values > 2.0:
            return 0.8
        elif values > 1.5:
            return 0.6
        elif values > 1.0:
            return 0.4
        elif values > 0.5:
            return 0.2
        elif values > 0.1:
            return 0.1
        else:
            return 0

    ratio = np.divide(
        total_low_ebitda,
        total_ebitda,
        out=np.zeros_like(total_ebitda),
        where=total_ebitda != 0,
    )
    ratio = ratio / minimum
    v_func = np.vectorize(check)
    new_ratio = v_func(ratio)
    if goal:
        return ratio
    return new_ratio * coefficient


def calc_fitness_global_nation(total_global_nation: np.array, minimum, coefficient):
    """
    Method to calculate the average of nation transfer throughout the years

    :param total_global_nation: array with the total global nation for each year
    :type total_global_nation: np.array
    :param minimum: minimum value present in the model config
    :type minimum: float
    :param coefficient: weight applied to the fitness
    :type coefficient: float

    :Usage:

    self.penalize_global_nation(total_global_nation, 0.25)

    :return:
        np.array: fitness of global nation per year
    :rtype np.array
    """

    return (total_global_nation / minimum) * coefficient


def calc_fitness_cti(cti, goal, coefficient):
    """
    Method to calculate the fitness of ct+i ebitda used in a solution

    :param cti: array with the ct+i ebitda of projects for all years
    :type cti: np.array
    :param goal: goal value present in the model config
    :type goal: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float

    :Usage:

    self.calc_fitness_cti(cti,20, 0.25)

    :return:
        np.array: fitness of ct+i
    :rtype np.array
    """
    cti_acum = np.cumsum(cti)
    return (cti_acum / goal) * coefficient


def calc_fitness_not_oil_jobs(not_oil_jobs, goal, coefficient):
    """
    Method to calculate the fitness of not oil jobs used in a solution

    :param not_oil_jobs: array with the not_oil_jobs of projects for all years
    :type not_oil_jobs: np.array
    :param goal: parameter with the goal for not_oil_jobs
    :type goal: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float

    :Usage:

    self.calc_fitness_not_oil_jobs(not_oil_jobs,20, 0.25)

    :return:
        np.array: fitness of not_oil_jobs
    :rtype np.array
    """

    return (not_oil_jobs / goal) * coefficient


def calc_fitness_students(students, goal, coefficient):
    """
    Method to calculate the fitness of students used in a solution

    :param students: array with the students of projects for all years
    :type students: np.array
    :param goal: parameter with the goal for students
    :type goal: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float

    :Usage:

    self.calc_fitness_students(students,20, 0.25)

    :return:
        np.array: fitness of students
    :rtype np.array
    """

    return (students / goal) * coefficient


def calc_fitness_km(km, goal, coefficient):
    """
    Method to calculate the fitness of km used in a solution

    :param km: array with the km of projects for all years
    :type km: np.array
    :param goal: parameter with the goal for km
    :type goal: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float

    :Usage:

    self.calc_fitness_km(km,20, 0.25)

    :return:
        np.array: fitness of km
    :rtype np.array
    """

    return (km / goal) * coefficient


def calc_fitness_access_gas(access_gas, goal, coefficient):
    """
    Method to calculate the fitness of access_gas used in a solution

    :param access_gas: array with the access_gas of projects for all years
    :type access_gas: np.array
    :param goal: parameter with the goal for access_gas
    :type goal: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float

    :Usage:

    self.calc_fitness_access_gas(access_gas,20, 0.25)

    :return:
        np.array: fitness of access_gas
    :rtype np.array
    """

    return (access_gas / goal) * coefficient


def calc_fitness_access_water(access_water, goal, coefficient):
    """
    Method to calculate the fitness of access_water used in a solution

    :param access_water: array with the access_water of projects for all years
    :type access_water: np.array
    :param goal: parameter with the goal for access_water
    :type goal: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float

    :Usage:

    self.calc_fitness_access_water(access_water,20, 0.25)

    :return:
        np.array: fitness of access_water
    :rtype np.array
    """

    return (access_water / goal) * coefficient


def calc_fitness_capex(capex):
    """
    Method to calculate the fitness of capex used in a solution

    :param capex: array with the capex of projects for all years
    :type capex: np.array

    :Usage:

    self.calc_fitness_capex(capex)

    :return:
        np.array: fitness of capex
    :rtype np.array
    """

    return capex


def calc_fitness_vpn(vpn, goal, coefficient):
    """
    Method to calculate the fitness of vpn used in a solution

    :param vpn: array with the vpn of projects for all years
    :type vpn: np.array
    :param goal: parameter with the goal for vpn
    :type goal: float
    :param coefficient: Parameter that gives weight to the fitness
    :type coefficient: float

    :Usage:

    self.calc_fitness_vpn(vpn,20, 0.25)

    :return:
        np.array: fitness of vpn
    :rtype np.array
    """

    return (vpn / goal) * coefficient
